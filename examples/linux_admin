#! /usr/bin/perl
#
#########################################################################
#        This Perl script is Copyright (c) 2003, Peter J Billam         #
#               c/o P J B Computing, www.pjb.com.au                     #
#                                                                       #
#     This script is free software; you can redistribute it and/or      #
#            modify it under the same terms as Perl itself.             #
#########################################################################

use Term::Clui;
use Term::Clui::FileSelect;
$debug = 0;
$hostname = `hostname`; $hostname =~ s/[\r\n]*//;
@PATH = split (":", $ENV{PATH});
my $daemon_d;
my @system_configs;
my $crond = &first_existing('/var/spool/cron/crontabs','/var/spool/cron');
my $squidlogd  = &first_existing('/usr/local/squid/logs','/var/squid/logs');
my $squidconfd = &first_existing('/usr/local/squid/etc','/etc/squid');
my $squid = &first_existing('/usr/local/squid/sbin/squid','/usr/sbin/squid');
my $sambalogd  = &first_existing('/usr/local/samba/var','/var/log/samba');
my $sambaconfd = &first_existing('/usr/local/samba/lib','/etc/samba');
my $apacheconfd = &first_existing( '/usr/local/apache/conf',
 '/usr/local/apache2/conf','/etc/apache2','/etc/apache');
@tasks = &tasks();
if (! @tasks) { die "Sorry, no administration tasks are available\n"; }
while () {
   $task = &choose ("Administrating $hostname", @tasks);
   if (! $task) { exit;
   } elsif ($task eq "Become superuser") { exec "su - -c $0";
   } elsif ($task eq "chpass")      { system "chpass";
   } elsif ($task eq "vipw")        { system "vipw";
   } elsif ($task eq "visudo")      { system "visudo";
   } elsif ($task eq "base-config") { system "base-config";
   } elsif ($task eq "aptitude")    { system "aptitude";
   } elsif ($task eq "mii-tool")    { system "mii-tool";
   } elsif ($task eq "adduser")     { &adduser();
   } elsif ($task eq "chkconfig")   { &chkconfig();
   } elsif ($task eq "update-rc.d") { &update_rcd();
   } elsif ($task eq "crontab")     { &crontab();
   } elsif ($task eq "Network ports") { &ports();
   } elsif ($task eq "system-config") { &system_config();
   } elsif ($task eq "Daemons")     { &daemons();
   } elsif ($task eq "Squid")       { &squid();
   } elsif ($task eq "Samba")       { &samba();
   } elsif ($task eq "Apache")      { &apache();
   } elsif (-f $task) { &edit ($task);
   } elsif (-d $task) {
		$file = &select_file(-TextFile=>1, -TopDir=>$task);
		if ($file) { &edit ($file) };
   }
}
sub tasks {
	my @tasks;
	if (! $>) {   # root stuff
   	foreach $f (
			qw(adduser aptitude base-config chkconfig chpass mii-tool
			sax sax2 update-rc.d vipw visudo yast yast2)) {
			if (&which($f)) { push @tasks, $f; }
		}
		if (opendir D, '/usr/bin') {
			@system_configs = sort grep /^system-config-/, readdir D; closedir D;
			if (@system_configs) { push @tasks, 'system-config'; }
			foreach (@system_configs) { s/^system-config-//; }
		}
	} else { push @tasks, 'Become superuser';
	}
	if (-d $crond) { push @tasks, 'crontab'; }
	foreach (
		'/etc/inittab',
		'/etc/sysconfig',
		'/etc/xinetd.d',
		'/etc/resolv.conf',
		'/etc/group',
		'/etc/iptables.up.rules',
		'/etc',
	) { if (-d $_ || -f $_) { push @tasks, $_; } }
	if (-d $squidlogd)   { push @tasks, 'Squid'; }
	if (-d $sambaconfd)  { push @tasks, 'Samba'; }
	if (-d $apacheconfd) { push @tasks, 'Apache'; }
	if (! $>) {
		foreach ('/etc/rc.d/init.d','/etc/init.d') {
			if (-d $_) {$daemon_d = $_; push @tasks, 'Daemons'; last}
		}
	};
	push @tasks, 'Network ports';
	return @tasks;
}
sub squid {
	my @tasks = ( 'tail -f access.log', 'tail -f access.log | grep',
	'tail -f cache.log');
	if ($squid && !$>) { push @tasks, 'Reconfigure'; }
	my $task = &choose('Squid ?', @tasks);
	return unless $task;
	if ($task =~ /(\w+\.log)$/) { system "tail -f $squidlogd/$1";
	} elsif ($task =~ /grep$/) {
		my $s = &ask ('look for what regexp ?');
		next unless $s;
		system "tail -f $squidlogd/access.log | grep '$s'";
	} elsif ($task eq 'Reconfigure') {
		if (! chdir $squidconfd) {
			&sorry("can't chdir $squidconfd: $!"); return;
		}
		&edit ('squid.conf');
		if (&confirm ('OK to "squid -k reconfigure" ?')) {
			system "$squid -k reconfigure";
		}
	} 
}
sub samba {
	my $sambabind = "/usr/bin";
	if (-d "/usr/local/samba/bin") { $sambabind = "/usr/local/samba/bin"; }

	my @tasks = ('log.smbd','log.winbindd');
	if (!$>) { push @tasks, 'smb.conf'; }
	if (-w "$sambaconfd/username.map") { push @tasks, 'username.map'; }
	my $task = &choose('Samba ?', @tasks);
	return unless $task;
	if ($task =~ /log/) { system "tail -f $sambalogd/$task";
	} elsif ($task =~ /grep$/) {
		my $s = &ask ('look for what regexp ?');
		next unless $s;
		system "tail -f $sambalogd/log | grep '$s'";
	} elsif ($task eq 'smb.conf' || $task eq 'username.map') {
		if (! chdir $sambaconfd) {
			&sorry("can't chdir sambaconfd: $!"); return;
		}
		while (1) {
			&edit ($task);
			my $retval = system "$sambabind/testparm";
			if ($? == -1) {
			 	&sorry("can't run testparm: $!\n"); return;
			} elsif ($? & 127) {
				&sorry (sprintf "testparm died with signal %d, %s coredump\n",
				($? & 127),  ($? & 128)?'with':'without'); return;
			} else {
				# $retval >> 8;
				if (! $retval) {
					if (&confirm ('OK to Reload Config ?')) {
						system "$sambabind/smbcontrol smbd reload-config";
						system "$sambabind/smbcontrol nmbd reload-config";
					}
					last;
				} else {
					warn "That didn't work, you'll need to re-edit smb.conf ...\n";
				}
			}
		}
	} 
}
sub apache {
	my $d = $apacheconfd;
	my $file; my $apachectl;
	my @tasks = ();
	my $enabled = &first_existing("$d/sites-enabled","$d/vhosts.d","$d/conf.d");
	if ($enabled) { push @tasks, "Edit a site"; }
	my $a2ensite = &which('a2ensite');
	if ($a2ensite)   { push @tasks, 'Enable a site'; }
	my $a2dissite = &which('a2dissite');
	if ($a2dissite)   { push @tasks, 'Disable a site'; }
	my $a2enmod = &which('a2enmod');
	if ($a2enmod)   { push @tasks, 'Enable a module'; }
	my $a2dismod = &which('a2dismod');
	if ($a2dismod)   { push @tasks, 'Disable a module'; }
	my $conff = &first_existing("$d/apache2.conf","$d/httpd.conf");
	if ($conff) { push @tasks, "Edit main config file"; }
	if (! @tasks) { return; }
	my $task = &choose("which apache task ?", @tasks);
	return unless $task;
	if ($task eq 'Edit a site') {
		my $site = &select_file
			(-Title=>'which site ?', -TextFile=>1, -TopDir=>$enabled, -Chdir=>0);
		return unless $site;
		&edit ($site);
	} elsif ($task eq 'Enable a site') {
		my $site = &select_file (-Title=>'which site ?', -TextFile=>1,
		 -TopDir=>"$d/sites-available", -Chdir=>0);
		$site =~ s/^.*\///;
		return unless $site;
		system "$a2ensite $site";
	} elsif ($task eq 'Disable a site') {
		my $site = &select_file (-Title=>'which site ?', -TextFile=>1,
		 -TopDir=>"$enabled", -Chdir=>0);
		$site =~ s/^.*\///;
		return unless $site;
		system "$a2dissite $site";
	} elsif ($task eq 'Enable a module') {
		my $module = &select_file (-Title=>'which module ?', -FPat=>'*.load',
		 -TopDir=>"$d/mods-available", -Chdir=>0);
		$module =~ s/^.*\///;
		return unless $module;
		system "$a2enmod $module";
	} elsif ($task eq 'Disable a module') {
		my $module = &select_file (-Title=>'which module ?', -FPat=>'*.load',
		 -TopDir=>"$d/mods-enabled", -Chdir=>0);
		$module =~ s/^.*\///;
		return unless $module;
		system "$a2dismod $module";
	} elsif ($task eq 'Edit main config file') {
		&edit ($conff);
	}
	my $apachectl = &which('apache2ctl') || &which('apachectl')
	 || '/usr/local/apache/bin/apachectl';
	if (&confirm ('OK to Restart Apache ?')) { system "$apachectl restart"; }
}
sub ports {
	if (! open (P, "netstat -a |")) {
		&sorry("can't run netstat -a: $!"); return 0;
	}
	my @lines; while (<P>) { if (/LISTEN|ESTABLISH/) { push @lines, $_; } }
	close P;
	&view ("Ports", join('', @lines));
}
sub daemons {
	my $task = &choose('Task ?','start','restart','stop');
	return unless $task;
	my $daemon = &select_file
		(-Title=>'which daemon ?', -TextFile=>1, -TopDir=>$daemon_d, -Chdir=>0);
	return unless $daemon;
	system "sh $daemon $task";
}
sub crontab {
	if ($>) { system "crontab -e"; return 0; }
	if (! opendir(D,$crond)) { warn "can't opendir $crond: \n"; return 0; }
	my @users = grep { !/^\./ } readdir(D);
	closedir D;
	if (! @users) { warn "no crontabs found in $crond\n"; return 0; }
	my $task = &choose('crontab task ?', 'View', 'Edit', 'Manual');
	return unless $task;
	if ($task eq 'Manual') { system 'man 5 crontab'; return; }
	my $user = &choose ("$task which user ?", @users);
	return unless $user;
	my $useropt = '-u '; if ($^O =~ /solaris/) { $useropt = ''; }
	if ($task eq 'Edit') { system "crontab -e $useropt $user";
	} else { system "crontab -l $useropt $user";
	}
}
sub chkconfig {
	if (! open (P, "chkconfig --list |")) {
		&sorry("can't run chkconfig --list: $!"); return 0;
	}
	my @l; my @xinetdl; while (<P>) {
		chop;
		if (/^\s/ || /based services/) { push @xinetdl, $_;
		} else { push @l, $_;
		}
	}
	if (open (F, '/etc/inittab')) {
		while (<F>) {
			if (/^\w+:(\d):initdefault:/) {warn "  default run-level $1\n"; last;}
		}
		close F;
	}
	my $r = `who -r 2>/dev/null`; $r =~ s/^\s*(\S+\s+\d+).*$/$1/;
	if ($r) { warn("currently $r"); }
	my $task = &choose('chkconfig task ?', 'View', 'Edit');
	return unless $task;
	if ($task eq 'Edit') {
		my %services;
		foreach (@l) { /^(\S+)\s+(.*)$/; $services{$1}=$2; }
		my $service = &choose('Edit which service ?', sort keys %services);
		return unless $service;
		&inform ($services{$service});
		my @runlevels = &choose('at which runlevels ?','1','2','3','4','5');
		return unless @runlevels;
		my $onoff =
		&choose("$service at runlevels ".join(",",@runlevels),'on','off');
		return unless $onoff;
		system "chkconfig --level ".join('',@runlevels)." $service $onoff";
	} else {
		&view('chkconfig --list', join("\n", (sort @l ),@xinetdl));
	}
	&view ('Daemon configuration', $s);
}
sub update_rcd {
	my $r = `who -r`; $r =~ s/^\s*(\S+\s+\d+).*$/$1/; warn("currently $r");
	my $task = &choose('update-rc.d task ?', 'View', 'Edit');
	return unless $task;
	if ($task eq 'Edit') {
		if (! opendir(D, '/etc/init.d')) {
			&sorry("can't opendir /etc/init.d: $!"); return 0;
		}
		my @l = sort grep
		{ !/^\.|^README|\.sh$|S$|^single$|^halt$|^reboot$/ } readdir(D);
		closedir D;
		my $service = &choose('Edit which service ?', @l);
		return unless $service;
		system "cd /etc ; ls rc[12345].d/S*$service*";
		my $onoff = &choose("$service at runlevels 2,3,4,5",'on','off');
		return unless $onoff;
		if ($onoff eq 'on') {
			my $startnumber = &choose("start-order number ?", 20 .. 99);
			system "update-rc.d $service defaults $startnumber";
		} elsif ($onoff eq 'off') {
			system "update-rc.d -f $service remove";
		}
	} else {
		local $/;
		&view('ls /etc/rc[2345].d', `ls -C --tabsize=75 /etc/rc[2345].d`);
	}
}
sub system_config {
	my $task = &choose('which system-config ?', @system_configs);
   return unless $task;
	system "/usr/bin/system-config-$task";
}
sub adduser {
	my $name =     &ask('new username  ?');
	if (getpwnam($name)) { &sorry("user $name already exists"); return 0; }
	my @groups = &choose('groups        ?', &groups());
	my $group; my @secondary_groups=();
	if (1 < scalar @groups) {
		$group = &choose('primary group ?', @groups);
		foreach (@groups) { if ($_ ne $group) { push @secondary_groups, $_; } }
	} else {
		$group = $groups[$[];
	}
	return unless $group;
	my $fullname = &ask('full name     ?');
	my $shell = &choose('login shell   ?', &shells());
	my $cmd = &which("adduser") . " -g $group";
	if (@secondary_groups) { $cmd .= " -G " . join(",",@secondary_groups) ; }
	if ($fullname) { $cmd .= " -c '$fullname'"; }
	if ($shell) { $cmd .= " -s $shell"; }
	$cmd .= " $name";
	&confirm("OK to $cmd ?") && system $cmd;
}
# ------------------------- infrastructure ----------------------
sub groups {
	my @groups=(); my $n;
	setgrent; while ($n = getgrent()) { push @groups, $n; } endgrent;
	sort @groups;
}
sub shells {
	my @shells; my $d; my $x;
	foreach $d ('/bin','/usr/bin') {
		if (! opendir(D,$d)) { &sorry("can't opendir $d: $!\n"); return ; }
		while ($_ = readdir D) {
			if (/sh$/ && !/ssh$/ && !/\.sh$/ && !/splash$/ && !/flash$/) {
				push @shells, "$d/$_";
			}
		}
		closedir D;
	}
	sort @shells;
}
sub first_existing {
	my $f = ''; foreach (@_) { if (-e $_) { $f = $_; last; } }
	return $f;
}
sub which { my $f; foreach $d (@PATH) { $f="$d/$_[$[]";  return $f if -x $f; } }
=pod

=head1 NAME

linux_admin - wrapper script for routine sysadmin of linux boxes

=head1 SYNOPSIS

# linux_admin

=head1 DESCRIPTION

This script, which comes along with the I<Term::Clui> Perl-module in its
I<examples> directory,
performs routine system administration
of linux boxes, particularly Fedora and Debian.
It integrates various programs such as
crontab, chkconfig, update-rc.d, visudo, vipw, starting and stopping
daemons, reconfiguring squid samba or apache, editing sysconfig or
running any of the system-config-* utilities, and much else.

=head1 AUTHOR

Peter J Billam  www.pjb.com.au/comp/contact.html

=head1 CREDITS

Based on Term::Clui

=head1 SEE ALSO

http://www.pjb.com.au/ ,
http://search.cpan.org/~pjb , 
Term::Clui,
a2enmod(1),
a2ensite(1),
a2dismod(1),
a2dissite(1),
adduser(1)
apache(1)
apache2ctl(1),
aptitude(1),
base-config(1),
chkconfig(1),
chpass(1),
crontab(1),
mii-tool(1),
samba(1),
sax(1),
sax2(1),
squid(1),
update-rc.d(1),
vipw(1),
visudo(1),
yast(1),
yast2(1),

=cut

